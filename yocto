#!/usr/bin/perl
#
# Yocto - An MPD client for the system notification area.
# Copyright (C) 2007-2012 nandhp <nandhp@gmail.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

use Encode qw/encode decode/;
use Gtk2;
use Gtk2::TrayIcon;
use File::Basename;			# Replace with File::Spec?
use File::Spec::Functions qw/:ALL/;
use File::Path;
use FindBin;
use Getopt::Long;
use IO::Socket::INET;
use warnings;
use strict;

my $VERSION = 0.56;

# Load "compilation" settings from footer (datadir). Also load text
# strings from header comments (name, description, copyright, license)
my $datadir = <DATA>;
if ( $datadir && $datadir =~ m/^datadir=(.+?)\s+$/ ) { $datadir = $1 }
else { $datadir = File::Spec->curdir() }
seek(DATA,0,0);				# Jump to the top of the file
my ($progname,$tagline,$copyright,$license) = (undef,undef,undef);
while (<DATA>) {
    last if m/^[^#]/;
    my ($text) = m/^#  +(.+)\s*$/;
    if ( !$text && !defined($license) ) {
	($progname,$tagline) = ($1,$2) if m/^# (.+?) - (.+)\s*$/;
	$copyright = $1 if m/^# Copyright \([Cc]\) (.+)\s*$/;
	next;
    }
    $license .= ($text||'')."\n";
}
$license =~ s/\s*$//;			# Remove trailing newlines

# Parse the command line arguments
Gtk2->init;				# To support GTK options
my $argvhost;
my $argvport;
my $argvpass;
my $trace = 0;
GetOptions('host|h=s' => \$argvhost,
	   'port|p=i' => \$argvport,
	   'password=s' => \$argvpass,
	   'trace+' => \$trace,
	   'help|usage|?' => \&UsageMsg,
	   'version' => \&VersionMsg) or UsageMsg();

# Finish loading
my %escapehtml = ('<'=>'&lt;', '>'=>'&gt;', '&'=>'&amp;', '"'=>'&quot;');
my $escapehtml = join('',keys(%escapehtml));
my $has_dbus = 0;
my $iconfile = findINC('yocto.svg');
$|=1;
$SIG{CHLD} = 'IGNORE';

# FIXME - For tracing
my %callbacknames = ();
if ( $trace ) { foreach ( [\&MPDResponseSimple, 'MPDResponseSimple'],
			  [\&MPDResponseStatus, 'MPDResponseStatus'],
			  [\&MPDResponseStats, 'MPDResponseStats'],
			  [\&MPDResponseInfo, 'MPDResponseInfo'],
			  [\&MPDResponsePlChanges, 'MPDResponsePlChanges'],
			  [\&MPDResponseOutputs, 'MPDResponseOutputs'],
			  [\&MPDResponseMCSongList, 'MPDResponseMCSongList'],
			  [\&MPDResponseMCList, 'MPDResponseMCList'],
			  [\&MPDResponseWelcome, 'MPDResponseWelcome'],
			  [\&MPDResponseMCSave, 'MPDResponseMCSave'] )
		  {$callbacknames{$_->[0]} = $_->[1] } }

# GTK initialization
Gtk2::Window->set_default_icon_list
  (Gtk2::Gdk::Pixbuf->new_from_file_at_size($iconfile, 16, 16),
   Gtk2::Gdk::Pixbuf->new_from_file_at_size($iconfile, 32, 32),
   Gtk2::Gdk::Pixbuf->new_from_file_at_size($iconfile, 48, 48),
   Gtk2::Gdk::Pixbuf->new_from_file_at_size($iconfile, 64, 64),
   Gtk2::Gdk::Pixbuf->new_from_file_at_size($iconfile,128,128));
my $tipobj = Gtk2::Tooltips->new;	# Tooltips widget

# Lookup XDG Music directory
my $xdghome = Glib::get_home_dir()||'';
my $xdgmusic = (eval {Glib::get_user_special_dir('music')})||$xdghome;
# Load the configuration file
my $configdir = catdir(Glib::get_user_config_dir(),'yocto');
my $configfile = catfile($configdir,'config');
my %config;
my %configcomments = ();
LoadConfig();			   # Load default configuration
MigrateConfig(catfile($ENV{HOME},'.yocto')) if $ENV{HOME};
LoadConfig($configfile);	   # Load user configuration
SaveConfig();			   # Save changes (e.g. from upgrades)

# MPD state
my %status = ();
my %mpd = ();
my %stats = ( db_update => 0 );
my @playlist = ();
my ($mpderror,$mpderrid) = (undef,0);
my $sock;
my $connecttime = 0;
my $iowatch;
my $iobuffer;
my @rq = ();
my %states = (play=>'Playing',pause=>'Paused',stop=>'Stopped');
my $savedstate = '';
my $savedsongid = -1;
my $savedtransition = 0;
my $savedplaylist = -1;
my $dboldupdate = 0;
my $dbwait = 1;
my $ongoingtransition = 0;
my $reconnectin = 0;
my $misc = undef;
my %misc = ();

# Notification Icon
my $iconsize = 0;
my @iconcolor = (-1,-1,-1);
my @iconpixbuf = ();
my $iconmode = 0;
my $oldiconmode = -1;
my ($msgvisible,$msghover,$msgtimeout) = (0,0,0);
my ($icon,$eventbox);

# Popup window
my @tip = ('Line 1','Line 2','Line 3','Line 4','Line 5');
my @oldtip = ('','','','','');
my $oldcover = '';
my $allowseek = 0;
my ($wndhover,$transfers,$pbcb) = (0,0,1);
my @labels = ();
my $timemousein;
my ($timeadjusting,$timeclicked) = (0,0);
my ($window,$playbutton,$timescale,$timeswitcher,$timebox,$coverview);

# Preferences Dialog
my $prefsdlg;
my @prefs_stats = ();
my @prefs_stats_l = ();
my $outputs_populated = 0;

# Music Chooser
my ($mcwnd, $mcsel, $mctree, $mctreemodel, $mcview, $mcsearch,
    $mcquery, $mcsearchlabel, $mcaccelgroup);
my $mcselmodel = Gtk2::ListStore->new('Glib::String',  # Identifier
                                      'Glib::String'); # Visible markup
my ($mcbutbox);
my $mcvisible = 0;
my ($mctype,$mcarg) = ('','');
my $mcreorder = 0;
my $mcscrollnext = 1;

# Initialize widgets
InitIcon();
InitWindow();

# Load plugins
#
# WARNING: Not a general-purpose plugin system. No user serviceable parts.
our @plugins = ();
my $plugindir = findINC('yocto-plugins');
if ( $plugindir and -d $plugindir ) {
    opendir(DIR,$plugindir);
    foreach ( readdir(DIR) ) {
	next if $_ =~ m/^\.|~$/;
	my $f = "$plugindir/$_";
	next unless -f $f and -s $f;
	next if $f =~ m/[\$#]$/;
	do $f or warn "Can't load plugin $f\n  Error(A): $@\n  Error(B): $!\n";
    }
}


# Show everything
$icon->show_all;
MPDDisconnect();
MenuConnect();				# Connect to MPD
UpdateTimeout();
Glib::Timeout->add(1000, sub { UpdateTimeout(); 1 });
#Glib::Timeout->add(1000*60, sub { Gtk2->main_quit }); # For Profiling

# Set up DBus
my $mediakeys;
eval {
    # Do nothing if DBus is not installed
    eval "use Net::DBus; use Net::DBus::Reactor; 1" or die;
    $has_dbus = 1;

    # Register the event handler
    my $bus = Net::DBus->find;
    my $service = $bus->get_service("org.gnome.SettingsDaemon");
    # The service moved at some point. Try connecting using both paths.
    foreach my $objpath ( "/org/gnome/SettingsDaemon/MediaKeys",
			  "/org/gnome/SettingsDaemon", "" ) {
	if ( $objpath ) { eval {
	    $mediakeys = $service->get_object($objpath);
	    $mediakeys->connect_to_signal(MediaPlayerKeyPressed => \&MediaKey);
	    1 } and last }
	else { $mediakeys = undef }
    }

    # Grab the keys. This should be repeated when the window gets
    # focus, but I don't really have any way to do that.
    GrabMediaKeys();

    # Set up a GTK-compatible Reactor, based on gmusicbrowser
    my $reactor = Net::DBus::Reactor->main();
    my %types = (read => 'in', write => 'out', exception => 'err');
    foreach my $type ( keys %{$reactor->{fds}} ) {
	my $gtktype = $types{$type} or die;
	foreach my $fd ( keys %{$reactor->{fds}->{$type}} ) {
	    Glib::IO->add_watch($fd, $gtktype, \&DBusDispatcher,
				[$reactor, $type, $fd]);
	}
    }
    my $timeout = $reactor->add_timeout(1, Net::DBus::Callback->new(method => sub {}));
    $reactor->step;
    $reactor->remove_timeout($timeout);
    1;
} or ($has_dbus = 0);

# Enter the main loop
Gtk2->main;

# Cleanup
ReleaseMediaKeys() if $has_dbus;
SaveConfig();				# Save configuration

# Functions only below this line.

# Utility and general functions

sub escapeHTML { local $_ = shift; s/([$escapehtml])/$escapehtml{$1}/eg; $_ }

sub findINC { # Locate a file by searching in some popular locations
    my $file = shift;
    if ($file =~ m(^/)) {
	return $file if (-e $file);
	return undef;
    }
    foreach my $dir ($datadir,$FindBin::Bin,@INC,path(),'.','/usr/local/share','/usr/share','/usr/share/pixmaps','/usr/local/share/pixmaps','/usr/share/yocto','/usr/local/share/yocto')
    {
	my $f = "$dir/$file";
	return $f if -e $f;
    }
    return undef;
}

sub FormatSong {
    my %song = @_;
    my @tip = ();

    my $track   = $song{Track};
    my $total   = $song{Track} && $song{Track} =~ m|(\d+)/(\d+)| ?
      ($track=$1,$2) : 0;
    my $file	= $song{file}||'';
    my $title	= $song{Title}||'';
    my $name	= $song{Name}||'';
    my $artist	= $song{Artist}||'';
    my $album	= $song{Album}||'';
    my $fstrip = $file =~ m/^\w+:\/\// ? $file : basename($file);

    # Try to fill in the data fields. For live streaming, use the
    # Title, Name and URL.
    $tip[0] = $title||$name||$fstrip||'(No Title)';
    if ( $name ) {
	if ( $title ) { $tip[1] = $name; $tip[2] = $fstrip } # With Track info
	else { $tip[1] = $fstrip; $tip[2] = ' ' } # Without track info
    }
    # For non-live media, use the album and artist.
    else {
	my $trackinfo = '';
	$album ||= '(No Album)';
	if ( $track && $total )
	  { $tip[1] = sprintf('%s (#%d of %d)', $album, $track,$total) }
	elsif ( $track ) { $tip[1] = sprintf('%s (#%d)', $album, $track) }
	else { $tip[1] = $album }
	$tip[2] = $artist || '(No Artist)';
    }
    $_ = escapeHTML($_) foreach @tip;	# For Pango markup
    return @tip;
}

sub FormatTime {
    # Format seconds as mm:ss, or hh:mm:ss if an hour or longer (and
    # subdivide the hours into days if requested and necessary)
    my ($sec,$usedays) = @_;
    my $hour = int($sec/3600);
    my $min = int($sec/60)%60;
    $sec = $sec%60;
    my $shour = sprintf('%d:',$hour);
    my $smin = sprintf($hour?'%02d':'%d',$min);
    $shour = sprintf('%d days, %d:', int($hour/24), $hour%24)
      if $usedays and $hour >= 24;
    sprintf('%s%s:%02d',$hour?$shour:'',$smin,$sec);
}

sub UpdateTimeout {
    # FIXME - Remove old code
    #MPDAuth(); # Check for authentication error, possibly requesting password

    # Not Connected
    if ( !$sock ) {
	MakeTooltip();
	MPDReconnect() if $reconnectin;
	return;
    }

    Update();
}

sub Update {
    # Request updates
    MPDPlChanges(-1) if $savedplaylist == -1;
    MPDStatus();
}

sub UpdateStatus {
    # Update the playlist
    if ( $savedplaylist == -1 ) { $savedplaylist = $status{playlist} }
    elsif ( $status{playlist} ne $savedplaylist ) {
	MPDPlChanges($savedplaylist);
	$savedplaylist = -1;
	return;	   # Wait for an up-to-date playlist before continuing
    }

    if ( $status{state} ne $savedstate ) {
	my $playing = $status{state} eq 'play';

	# Show the state icon
	$iconmode = $playing ? 1 : 0;
	if ( $oldiconmode ne $iconmode ) { IconExpose() }

	# Show the track info
	$pbcb = -1; $playbutton->set_active($playing); $pbcb = 1;

	# Show the tooltip
	StartTransition(3) if $savedstate;
    }

    MakeTooltip();

    if ( $savedsongid ne (defined($status{songid})?$status{songid}:-1)
	 or $savedstate ne $status{state}||'' ) {
	# or $savedplaylist ne $status{playlist}
	InvalidatePrefs();
    }

    # Update the MusicChooser
    if ( $savedsongid ne (defined($status{songid})?$status{songid}:-1) and
	 $mctype eq 'np' ) { $mcscrollnext = 0; MC_Repopulate() }

    # Update the stats
    if ( $dboldupdate eq $stats{db_update} and $dbwait > 0 )
      { MPDStats(); $dbwait-- }

    # Refill the playlist
    my $refill = $config{External}{RefillCommand};
    if ( $refill and !$status{repeat} and !$status{random} and
         !$status{single} and
	 ($status{song}||-1)+1 == $status{playlistlength} ) {
	system $refill;
    }

    &$_($status{state}) foreach @plugins;

    # Save the state to detect changes
    $savedstate = $status{state}||'';
    $savedsongid = defined($status{songid})?$status{songid}:-1;
}

sub UpdatePlaylist {
    # Apply the changes to the playlist
    my @changes = @_;
    foreach ( @changes ) {
	$playlist[$_->{Pos}] = $_;
    }
    if ( exists($status{playlistlength}) )
      { pop @playlist while @playlist > $status{playlistlength} }
    $savedplaylist = exists($status{playlist}) ? $status{playlist} : -1;
    $savedsongid = -1;

    # Update playlist display in MusicChooser
    if ( $mctype eq 'np' ) { $mcscrollnext = 0; MC_Repopulate() }

    # Now, make sure everything else is using this information
    UpdateStatus() if $savedplaylist > -1;
}

sub UpdateStats {
    $prefs_stats_l[0] = sprintf("Artists: %d",$stats{artists});
    $prefs_stats_l[1] = sprintf("Albums: %d",$stats{albums});
    $prefs_stats_l[2] = sprintf("Songs: %d",$stats{songs});
    $prefs_stats_l[3] = sprintf("Total playing time: %s",
				FormatTime($stats{db_playtime},1)); # Use days
    $prefs_stats_l[4] = sprintf("Last refresh: %s",
				scalar localtime($stats{db_update}));
    if ( @prefs_stats )
      { $prefs_stats[$_]->set_text($prefs_stats_l[$_]) foreach 0..4 }
}

sub MakeTooltip {
    my $state = $states{$status{state}||''};
    my %song  = ();
    %song = %{$playlist[$status{song}]}
      if defined($status{song}) and $playlist[$status{song}];
    my @timeinfo = ();

    my $trackchanged =
      ($savedstate ne ($status{state}||'') or
       $savedsongid != (defined($status{songid})?$status{songid}:-1));

    if ( !$sock ) {
	@tip = ('Not Connected',
		$mpderror ? sprintf('Disconnected: %s',$mpderror) : '',
		$reconnectin ? sprintf('Reconnecting in %s seconds...',
				       $reconnectin-1) : '', '', 'Playlist');
    }
    elsif ( !$song{file} || $status{state} eq 'stop' )
      { @tip = ('Not Playing','','','','Playlist') }
    else {
	if ( $trackchanged or $status{playlist} ne $savedplaylist ) {
	    @tip = FormatSong(%song);
	    $tip[4] = sprintf('%d of %d',
			      $status{song}+1, $status{playlistlength});
	}
	@timeinfo = split(':',($status{time}||''));
       	$tip[3] = $timeinfo[1]
	  ? sprintf('%s/%s', FormatTime($timeinfo[0]),FormatTime($timeinfo[1]))
	    : FormatTime($timeinfo[0]);
    }

    UpdateLabels();

    # Cover art
    if ( $trackchanged ) {
	my $cover = '';
	if ( !$config{External}{MusicDirectory}
	     || !$config{Settings}{ShowCovers} ) { # Covers off or unavailable
	    SetCover('');
	}
	elsif ( $song{Name} or ($song{file}||'') =~ m/^\w+:\/\// ) {
	    SetCover('');      # Streams have no covers, unfortunately
	}
	elsif ( !$song{file} || $status{state} eq 'stop' ) { SetCover('') }
	else {
	    my $d = catdir($config{External}{MusicDirectory},
			   dirname($song{file}));
	    opendir DIR, $d;
	    my @f = sort grep { PickCover($d,$_) } readdir DIR;
	    closedir DIR;
	    if ( @f == 1 || @f ) { SetCover(catfile($d,$f[0])) }# Ambiguous too
	    elsif ( @f == 0 ) { SetCover('') }
	}
    }

    # Time scale
    if ( $timescale ) {
	$timeadjusting = 1;
	if ( $trackchanged ) {
	    $allowseek =		# No seek if no length information
	      ( @timeinfo == 2 && $timeinfo[1] && defined($timeinfo[0])
		&& $timeinfo[1] >= $timeinfo[0] ) ? 1 : 0;
	    SetTimebox($timebox) if !$allowseek;
	    $timescale->set_range(0,$timeinfo[1]||1);
	}
	$timescale->set_value($timeinfo[0]||0) unless $timeclicked;
	$timeadjusting = 0;
    }

    HideTooltip();			# Handle all popup display
}

sub SetCover {
    my ($cover) = @_;
    return if $oldcover eq $cover;
    $oldcover = $cover;
    foreach my $w ( $coverview ) {
	my $cv = $w->get_child();
	if ( $cover && -e $cover ) {
	    my $coversize = $cv->allocation->height;
	    my $pixbuf = eval { Gtk2::Gdk::Pixbuf
		->new_from_file_at_size($cover, $coversize, $coversize) }
	      || eval {
		  my $pixbuf = $window->render_icon('gtk-missing-image',
						    'dialog');
		  $pixbuf->scale_simple($coversize,$coversize,'hyper') };
	    $cv->set_from_pixbuf($pixbuf);
	    $w->set_padding(0,0,0,5);
	}
	else { $cv->clear(); $w->set_padding(0,0,0,0) }
    }
}

sub PickCover {
    my ($d,$f) = @_;
    return 0 unless -e "$d/$f";
    return 0 unless $f =~ m/(cover|folder)\.(jpe?g?|pn[gm]|gif|svg|[xp][pb]m)/i;
    return 1;
}

# Popup (tooltip) window

sub InitWindow {
    my $winbox = Gtk2::VBox->new(0,0);
    my $textbox = Gtk2::VBox->new(0,0);
    my $labelidx = @labels;
    push @labels,
      (InitLabel(),InitLabel(),InitLabel(),InitLabel(),Gtk2::Label->new());
    foreach ( $labelidx..$labelidx+2 ) {
	$textbox->pack_start($labels[$_],0,0,0);
	# Only works with Compiz
	#$labels[$_]->signal_connect('expose-event',\&EllipsizedLabelTooltip);
    }
    $winbox->pack_start($textbox,0,0,0);

    # Buttons
    my $butbox = Gtk2::HBox->new(0,3);

    # Play button
    $playbutton = Gtk2::ToggleButton->new(); AllowTransfers($playbutton);
    ConfigureButtonFromStock($playbutton, 'gtk-media-play', 'menu');
    $playbutton->signal_connect('toggled', \&PlayButton);
    $butbox->pack_start($playbutton,0,0,0);

    # Previous button
    my $button = Gtk2::Button->new(); AllowTransfers($button);
    ConfigureButtonFromStock($button, 'gtk-media-previous', 'menu');
    $button->signal_connect('clicked', \&MenuPrev);
    $butbox->pack_start($button,0,0,0);

    # Next button
    $button = Gtk2::Button->new(); AllowTransfers($button);
    ConfigureButtonFromStock($button, 'gtk-media-next', 'menu');
    $button->signal_connect('clicked', \&MenuNext);
    $butbox->pack_start($button,0,0,0);

    # Time display and/or HScale
    $timebox = Gtk2::EventBox->new();
    $labels[3]->set_alignment(0.5, 0.5); $labels[3]->set_justify('center');

    $timeswitcher = Gtk2::HBox->new();

    # Set up time HScale
    $timescale = Gtk2::HScale->new(undef);
    $timescale->signal_connect('format-value',sub { FormatTime($_[1]) });
    $timescale->signal_connect('value-changed', sub { MPDSeek($status{song},int($timescale->get_value)) if !$timeadjusting; 0 });
    $timescale->set_update_policy('delayed');
    #$timescale->set_draw_value(0);
    $timescale->set_value_pos('left');

    # Set up time Label
    $timebox->add($labels[3]);
    $timeswitcher->add($timebox);

    # Set up HScale event handlers (this is complicated, and buggy!)
    $timebox->add_events('pointer-motion-mask');
    $timebox->signal_connect('motion-notify-event', sub {
				 WndEnter(@_);
				 return unless $allowseek;
				 $timemousein = 1;
				 SetTimebox($timescale);
			     });
    $timescale->signal_connect('leave-notify-event', sub {
				   $timemousein = 0;
				   return if $timeclicked;
				   WndLeave(@_);
				   $timemousein=0;
				   Glib::Timeout->add
				       (10, sub { return if $timemousein;
						  SetTimebox($timebox) });
			       });
    $timescale->signal_connect('enter-notify-event', sub {
				   WndEnter(@_);
				   $timemousein = 1;
			       });
    $timescale->signal_connect('button-press-event',sub { $timeclicked=1;0 });
    $timescale->signal_connect('button-release-event',sub { $timeclicked=0;0 });
    $butbox->pack_start($timeswitcher,1,1,0);

    # Playlist button
    $button = Gtk2::Button->new(); AllowTransfers($button);
    my $bbox = Gtk2::HBox->new();
    $bbox->pack_start(Gtk2::Image->new_from_stock('gtk-index','menu'),0,0,0);
    $bbox->pack_start($labels[4],0,0,0);
    $button->add($bbox);
    $button->signal_connect('clicked', \&ShowPlaylist);
    $button->signal_connect('button-release-event', \&PlaylistButtonFunc);
    $tipobj->set_tip($button,'Playlist');
    $butbox->pack_end($button,0,0,0);

    $butbox->set_size_request(300,-1);
    $winbox->pack_end($butbox,0,0,0);

    # Cover viewer
    my $coverbox = Gtk2::HBox->new(0,0);
    $coverview = Gtk2::Alignment->new(0,0.5,1,1);
    $coverview->add(my $coverimage = Gtk2::Image->new());
    $coverbox->pack_start($coverview,0,0,0);
    $coverbox->pack_start($winbox,1,1,0);

    # Window
    $window = Gtk2::Window->new('popup');
    $window->add($coverbox);
    $coverbox->show_all;
    $window->set_border_width(5);
    $window->set_app_paintable(1);
    $window->signal_connect('expose-event',\&PopupExpose);
    $coverimage->signal_connect('size-allocate',
				sub { SetCover($oldcover);
				      ShowTooltip(0); 1 });

    $window->set_decorated(0);
    $window->set_resizable(0);
    $window->realize;
    # Not sure if this is safe, it's not documented:
    # eval { $window->set_type_hint('tooltip'); };
    AllowTransfers($window);
}

sub InitLabel {
    my $label = Gtk2::Label->new();
    $label->set_alignment(0, 0);
    $label->set_padding(0,0);
    $label->set_ellipsize('end');
    return $label;
}

sub ConfigureButtonFromStock {
    my ($w,$stock,$size) = @_;
    # Add a stock icon
    $w->add(Gtk2::Image->new_from_stock($stock,$size));
    # Set the tooltip to the label, but stripping out the mnemonic.
    # This might not be properly internationalized.
    my $stockt = Gtk2::Stock->lookup($stock)->{label};
    $stockt =~ s/\(_[a-zA-Z]\)|_(?!_)//;
    $tipobj->set_tip($w,$stockt);
}

sub UpdateLabels {
    my $wrapped = '<span weight="bold" size="large">'.$tip[0].'</span>';
    foreach ( 0..$#labels ) {
	my $idx = $_ % 5;
	$labels[$_]->set_markup($idx == 0 ? $wrapped: $tip[$idx])
	  if $tip[$idx] ne $oldtip[$idx];
    }
    if ( ($status{state}||'') eq 'play' and $tip[0] ne $oldtip[0] ) {
	StartTransition(3); # Notify of changing title, e.g. for streaming
    }
    @oldtip = @tip;
}

sub SetTimebox {
    my ($w) = @_;
    #return if $w->get_parent()||'' eq $timebox;
    $timeswitcher->foreach(sub { $timeswitcher->remove($_[0]) });
    $timeswitcher->add($w);
    $timeswitcher->show_all;
}

sub EllipsizedLabelTooltip {
    my ($win,$event,$l) = @_;
    # Note: Requires Pango 1.16 (and appropriately recent bindings!)
    eval { $tipobj->set_tip($l, $l->get_layout()->is_ellipsized() ?
			    $l->get_text() : '') };
    return 0;
}

sub PopupExpose {
    my $win = $window->window;
    my ($w,$h) = $window->get_size();
    # Draw a fancy etched border
    $window->get_style()->paint_box($win, 'normal', 'out', undef, $window,
				    '', 0, 0, $w, $h);

    # Required when not under Compiz, can't attach the label itself.
    EllipsizedLabelTooltip(undef,undef,$_) foreach @labels;

    return 0;
}

sub ShowTooltip {
    my ($newone) = @_;
    $msgtimeout = int($newone/1000) if $newone > 100;
    $msgtimeout = 0 if $newone && $newone < 100;

    return unless $newone || $msgvisible; # Do nothing if popup hidden!
    return unless $icon->get('embedded'); # Don't show popup if icon missing!

    # Compute position
    my ($wndx,$wndy) = $eventbox->window->get_origin();
    my ($iconw,$iconh) = $icon->get_size_request();
    my ($wndw,$wndh) = $window->get_size();
    my ($scrw,$scrh) = (Gtk2::Gdk->screen_width(), Gtk2::Gdk->screen_height());
    if ( $wndx < $iconw ) { $wndx = $iconw }
    if ( $wndy < $iconh ) { $wndy = $iconh }
    if ( $wndx + $wndw > $scrw ) { $wndx = $scrw-$wndw-$iconw }
    if ( $wndy + $wndh > $scrh ) { $wndy = $scrh-$wndh-$iconh }

    my $oldallowseek = $allowseek;
    $allowseek = 0;
    $window->move($wndx,$wndy);
    $window->show;
    $allowseek = $oldallowseek;
    $msgvisible = 1;
}

sub HideTooltip {
    $msgtimeout = 0;
    return ShowTooltip(1) if DuringTransition() or $msghover or $wndhover;
    $msgvisible = 0;
    $window->hide;
    # In case the leave event wasn't called, which appears to happen
    # occasionally.
    $timemousein = 0;
    SetTimebox($timebox);
}

sub StartTransition {
    my ($t) = @_;
    return unless $t >= 1 and $config{Settings}{TrackNotify};
    $t += time;
    $ongoingtransition = $t if $t > $ongoingtransition;
    ShowTooltip(1);
}

sub DuringTransition {
    return $ongoingtransition = 0 if !$config{Settings}{TrackNotify} or !$sock;
    return 1 if $ongoingtransition > time;
    return 0 if ($status{state}||'') ne 'play';
    my @timeinfo = split(':',$status{time});
    if ( #( $timeinfo[1] and $timeinfo[1]-$timeinfo[0] <= 1 ) or
	 $timeinfo[0] <= 3 ) {
	return 1;
    }
    return 0;
}

sub WndEnter { $wndhover = 1;                 return 0 }
sub WndLeave { $wndhover = 0; MakeTransfer(); return 0 }

sub MakeTransfer {
    #$transfers++;
    Glib::Timeout->add(400, \&DoTransfer);
}

sub DoTransfer {
    $transfers--;
    return if $transfers > 0;
    HideTooltip();
    return 0;
}

sub AllowTransfers {
    $_[0]->signal_connect('enter-notify-event' => \&WndEnter);
    $_[0]->signal_connect('leave-notify-event' => \&WndLeave);
}

# Notification Icon

sub InitIcon {
    $icon = Gtk2::TrayIcon->new('yocto');
    $eventbox = Gtk2::EventBox->new(); # The EventBox for the notification icon
    $icon->add($eventbox);
    $eventbox->set_app_paintable(1);
    $eventbox->signal_connect('expose-event', \&IconExpose);
    $eventbox->signal_connect('size-allocate',\&IconAllocate);
    $eventbox->signal_connect('button-press-event' => \&ButtonEvent);
    $eventbox->signal_connect('enter-notify-event' => \&MouseEnter);
    $eventbox->signal_connect('leave-notify-event' => \&MouseLeave);
    $eventbox->signal_connect('scroll-event' => \&ButtonEvent);
    $icon->signal_connect('destroy' => \&IconDestroyed);
    $eventbox->set_visible_window(0);
}

sub IconExpose {
    my ($size) = $icon->get_size_request();
    my $win = $eventbox->window;
    # Get the preferred foreground color
    my ($fgc) = $icon->get_style()->fg_gc('normal');
    my $color = $icon->get_style()->fg('normal');
    my @cval = (int($color->red*255/65535), int($color->green*255/65535),
		int($color->blue*255/65535));
    my $colorchanged = 0;
    for ( 0..2 ) { $colorchanged = 1 if $cval[$_] ne $iconcolor[$_] }
    if ( @iconpixbuf != 2 or ($iconsize ne $size) or $colorchanged ) {
	my $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file_at_size
	  ($iconfile,$size,$size);
	# A possibly fragile routine to munge the alpha channel to
	# produce a "paused" version of the logo. First try to ensure
	# the image is RGBA, then (for each channel) munge every
	# fourth character in the string. There is very little
	# documentation on how to do any of this.
	my ($cw,$ch) = ($pixbuf->get_width, $pixbuf->get_height);
	my ($cr,$ccs) = ($pixbuf->get_rowstride, $pixbuf->get_colorspace);
	my ($cha,$cnc) = ($pixbuf->get_has_alpha, $pixbuf->get_n_channels);
	if ( !$cha or $cnc != 4 or $ccs ne 'rgb' ) {
	    warn "Logo cannot be edited: Wrong colorspace or alpha channel";
	    # We keep going in any case, but let's try adding an alpha
	    # channel, just in case that will help.
	    $pixbuf = $pixbuf->add_alpha(0,0,0,0);
	}
	my $pixels = $pixbuf->get_pixels();
	# Tint the icon to the user's preferred forground color
	if ( $color ) {
	    for my $channel ( 0..2 ) {
		for ( my $i = $channel; $i < length($pixels); $i+=4 ) {
		    substr($pixels,$i,1,chr($cval[$channel]));
		}
	    }
	    $pixbuf = Gtk2::Gdk::Pixbuf->new_from_data
	      ($pixels, $ccs, 1, 8, $cw, $ch, 4*$cw);
	}
	# Generate the "paused" image by adjusting the alpha channel
	for ( my $i = 3; $i < length($pixels); $i+=4 ) {
	    substr($pixels,$i,1,chr(int(ord(substr($pixels,$i,1))*0.25)));
	}
	my $offpixbuf = Gtk2::Gdk::Pixbuf->new_from_data
	  ($pixels, $ccs, 1, 8, $cw, $ch, 4*$cw);
	@iconpixbuf = ($offpixbuf, $pixbuf);
	$iconsize = $size;
	@iconcolor = @cval;
    }
    return unless $fgc;

    # Use clear() instead of draw_rect($bg_gc) because the latter
    # doesn't work with a transparent panel. This behavior of
    # Gtk2::Gdk::Window::clear() is not documented anywhere.
    $win->clear();
    $win->draw_pixbuf($fgc, $iconpixbuf[$iconmode],
		      0, 0, 0, 0, $size, $size, 'none',0,0);
    $oldiconmode = $iconmode;
}

sub IconAllocate {
    my ($wx,$alloc) = @_;
    my ($oldsize) = $icon->get_size_request();
    my ($w,$h) = ($alloc->width,$alloc->height);
    #print "A $w $h\n";
    #if ( 1 ) {
    my $size = $w > $h ? $w : $h;
    $size = 64 if $size > 64;
    if ( $h == $oldsize ) { $size = $w }
    if ( $w == $oldsize ) { $size = $h }
    $icon->set_size_request($size,$size) if $size != $oldsize;
    #}
}

sub ButtonEvent {
    my ($obj,$event) = @_;
    if ( $event->type eq 'scroll' ) {
	# Wheel up/down to adjust volume: highly unorthodox, according
	# to the HIG folks, but most music players do something with
	# the wheel, either for volume or track switching.
	if ( $sock && defined($status{volume}) ) {
	    if ( $event->direction eq 'up' and $status{volume} < 100 )
	      { MPDVolume($status{volume}+1) }
	    elsif ( $event->direction eq 'down' and $status{volume} > 0 )
	      { MPDVolume($status{volume}-1) }
	    elsif ( $event->direction eq 'right' ) { MPDNext() }
	    elsif ( $event->direction eq 'left' ) { MPDPrev() }
	    Update();
	}
    }

    elsif ( $event->button == 1 ) { $playbutton->clicked() } # Toggle playback

    elsif ( $event->button == 3 ) {
	MouseLeave();
	IconMenu($event);
    }
    return 1;
}

sub IconMenu {
    my ($event) = @_;
    my $menu = Gtk2::Menu->new(); my $item;

    $item = Gtk2::ImageMenuItem->new('Next A_lbum');
    $item->signal_connect('activate',\&NextAlbum);
    $menu->append($item);

    $menu->append(Gtk2::SeparatorMenuItem->new());

    $item = Gtk2::CheckMenuItem->new('Ra_ndom');
    $item->set_active($status{random});
    $item->set_sensitive($sock ? 1 : 0);
    $item->signal_connect('toggled',\&ToggleRandom);
    $menu->append($item);

    $item = Gtk2::CheckMenuItem->new('R_epeat');
    $item->set_active($status{repeat});
    $item->set_sensitive($sock ? 1 : 0);
    $item->signal_connect('toggled',\&ToggleRepeat);
    $menu->append($item);

    $item = Gtk2::CheckMenuItem->new('_Single');
    $item->set_active($status{single});
    $item->set_sensitive($sock ? 1 : 0);
    $item->signal_connect('toggled',\&ToggleSingle);
    $menu->append($item);

    $item = Gtk2::CheckMenuItem->new('_Consume');
    $item->set_active($status{consume});
    $item->set_sensitive($sock ? 1 : 0);
    $item->signal_connect('toggled',\&ToggleConsume);
    $menu->append($item);

    $menu->append(Gtk2::SeparatorMenuItem->new());

    $item = Gtk2::ImageMenuItem->new_from_stock('gtk-preferences');
    $item->signal_connect('activate',\&MenuPrefs);
    $menu->append($item);

    $item = Gtk2::ImageMenuItem->new_from_stock
      ($sock ? 'gtk-disconnect' : 'gtk-connect');
    $item->signal_connect('activate',$sock ? \&MPDDisconnect : \&MenuConnect);
    $menu->append($item);

    $menu->append(Gtk2::SeparatorMenuItem->new());

    $item = Gtk2::ImageMenuItem->new_from_stock('gtk-help');
    $item->signal_connect('activate',\&ShowHelp);
    $menu->append($item);

    $item = Gtk2::ImageMenuItem->new_from_stock('gtk-about');
    $item->signal_connect('activate',\&AboutBox);
    $menu->append($item);

    $menu->append(Gtk2::SeparatorMenuItem->new());

    $item = Gtk2::ImageMenuItem->new_from_stock('gtk-quit');
    $item->signal_connect('activate',sub { Gtk2->main_quit });
    $menu->append($item);

    $menu->show_all;
    $menu->popup(undef,undef,undef,undef,$event->button,$event->time);
}

sub MouseEnter {
    $msghover = 1;
    ShowTooltip(1);
    return 1;
}

sub MouseLeave {
    $msghover = 0;
    MakeTransfer();
    return 1;
}

sub IconDestroyed {
    # Quit when the tray icon goes away. This avoids the problem of
    # having multiple copies running inadvertently.
    Gtk2->main_quit;
}

# Command handlers and callbacks

sub NextAlbum {
    my $refill = $config{External}{RefillCommand};
    my $album = $playlist[$status{song}]{Album}||'';
    my $found = -1;
    foreach ( $status{song}+1..$#playlist ) {
	if ( ($playlist[$_]{Album}||'') ne $album ) { $found = $_; last }
    }
    # If random or single mode is turned on, just go to the next track
    if ( $status{random} || $status{single} ) { MPDNext() }
    # If there is a suitable track coming up, seek to it
    elsif ( $found >= 0 ) { MPDSeek($found, 0) }
    # Otherwise, if repeat mode is turned on, wrap around to the first track
    elsif ( $status{repeat} ) { MPDSeek(0, 0) }
    # If all else fails, run the refill command, and go to the next track
    else {
	MPDSeek($#playlist, 0);
	system $refill if $refill;
	MPDNext();	# MPD will stop if refill fails or is disabled
    }
}

sub MenuConnect {
    if ( $config{Connection}{AutoConnect} ) { MPDConnect(1) }
    else { Prefs(1) }
}
sub MenuPrefs { Prefs(0) }

sub MenuPrev { MPDPrev(); Update() }
sub MenuNext { MPDNext(); Update() }
sub PlayButton {
    my ($b) = @_;
    if ( $pbcb == 0 ) {
	$pbcb = -1;
	$b->set_active(0);
	$pbcb = 0;
    }
    if ( $pbcb != 1 ) { return }
    # Make the state come into effect (e.g. !active means to pause)
    elsif ( !$b->get_active() && defined($status{song}) ) {
	my %song = %{$playlist[$status{song}]};
	my $streaming = ( (exists($song{Name}) && $song{Name}) or # Icecast
			  ($song{file}||'') =~ m/^\w+:\/\// ); # MP3-over-HTTP
	if ( $streaming ) { MPDStop() }
	else { MPDPause() }
    }
    else { MPDPlay() }
    Update();
}
sub ToggleRandom { my ($w) = @_; MPDRandom($w->get_active()?1:0) }
sub ToggleRepeat { my ($w) = @_; MPDRepeat($w->get_active()?1:0) }
sub ToggleSingle { my ($w) = @_; MPDSingle($w->get_active()?1:0) }
sub ToggleConsume{ my ($w) = @_; MPDConsume($w->get_active()?1:0) }

sub MediaKey {
    my ($app, $key) = @_;
    return unless $app eq 'Yocto';
    if ( $key eq 'Play' or $key eq 'Pause' )
      { StartTransition(3); $playbutton->clicked() }
    elsif ( $key eq 'Stop' and $playbutton->get_active() )
      { StartTransition(3); $playbutton->clicked() }
    elsif ( $key eq 'Next' )
      { StartTransition(3); MenuNext() }
    elsif ( $key eq 'Previous' )
      { StartTransition(3); MenuPrev() }
}
sub GrabMediaKeys {
    return unless $has_dbus and $mediakeys;
    $mediakeys->GrabMediaPlayerKeys('Yocto', 0);
}
sub ReleaseMediaKeys {
    return unless $has_dbus and $mediakeys;
    $mediakeys->ReleaseMediaPlayerKeys('Yocto');
}

sub ShowPlaylist {
    MC_Show();
    $mcwnd->present();
}

sub PlaylistButtonMenuDetach {
    ShowTooltip(0);
}

sub PlaylistButtonFunc {
    my ($widget, $event) = @_;
    return 0 unless $event->button == 3;
    my $menu = Gtk2::Menu->new();
    AllowTransfers($menu);
    $menu->attach_to_widget($widget, \&PlaylistButtonMenuDetach);

    my $iter = $mcselmodel->get_iter_first();
    return 1 unless $iter;
    do {
        my ($itemid, $itemname) = $mcselmodel->get($iter,0, 1);
        (my $itemtype, $itemid) = split ':', $itemid;
        if ( $itemtype eq 'pl' ) {
            $itemname =~ s/_/__/g;
            my $menuitem = Gtk2::MenuItem->new($itemname);
            $menuitem->signal_connect('activate', sub {
                MPDClear(); MPDPlLoad($itemid); MPDPlay(0);
                Update(); MC_Repopulate(); });
            $menu->add($menuitem);
        }
    }
    while ( $iter = $mcselmodel->iter_next($iter) );
    $menu->show_all;
    $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
    return 1;
}

sub ShowHelp {
    if ( fork == 0 ) {			# Fork returns undef if it fails
	my $bin = findINC('xterm') || findINC('gnome-terminal') ||
	  findINC('x-terminal-emulator');
	exec $bin, '-title', 'Yocto Help', '-e', 'sh', '-c',
	      'man yocto||(echo Press ENTER...;head -1)';
	die 'Could not load xterm for help viewer';
    }
}

sub AboutBox {
    my $about = Gtk2::AboutDialog->new();
    $about->set_name('Yocto');
    $about->set_version(sprintf('%1.2f',$VERSION));
    $about->set_comments($tagline);
    $about->set_copyright("\251".$copyright);
    $about->set_license($license);
    $about->signal_connect('response', sub { $_[0]->destroy() });
    $about->show();
}

sub UsageMsg { print STDERR "Usage: yocto [options]\n"; exit }
sub VersionMsg {
    printf STDERR <<END, $VERSION,$tagline,$copyright,$license;
Yocto %1.2f - %s
Copyright (C) %s

%s

END
    exit(0);
}

sub DBusDispatcher {
    my ($reactor,$type,$fd) = @{$_[2]};
    return 0 unless $reactor->{fds}->{$type}->{$fd}->{enabled};
    $reactor->{fds}->{$type}->{$fd}->{callback}->invoke;
    $_->invoke foreach $reactor->_dispatch_hook();
    return 1;
}

sub NoFunction {
    my $dialog = Gtk2::MessageDialog->new_with_markup
      ($icon, 'modal', 'error', 'ok',
       '<span weight="bold" size="large">Error</span>'."\n\n".
       'This function is not yet available.');
    $dialog->set_title('Yocto');
    $dialog->run;
    $dialog->destroy;
}

# Configuration file

sub DefaultConfig {
    # The default configuration file
    my $config = <<END;
[Settings]
# Show notification when the track changes
TrackNotify=1
# Show cover art (Requires MusicDirectory)
ShowCovers=1

[External]
# Set this to MPD's music_directory
MusicDirectory=$xdgmusic
# Runs whenever the last track is selected
RefillCommand=
# Command to start MPD if AutoStart is on
MPDCommand=mpd

[Connection]
# The MPD host (For remote access only)
MPDHost=
# The MPD port (Default is 6600)
MPDPort=
# Password for MPD (If necessary)
MPDPass=
# Try to connect to MPD at startup
AutoConnect=1
# Try starting MPD if connection fails
AutoStart=0
END
    my @config = ();
    push @config, $1 while $config =~ m/^(.*?\r?\n)/gm;
    return \@config;
}

sub LoadConfig {
    # Read the configuration file into the hash. Overwrite
    # existing items, but do not remove them.
    my ($configfile) = @_;
    my @input;
    if ( $configfile and open F, '<', $configfile ) { @input = <F>; close F }
    elsif ( $configfile ) { return }
    else { @input = @{DefaultConfig()} }

    my $section = '';
    my $comment = '';
    foreach my $l ( @input ) {
	if ( $l =~ m/^\s*(\w+?)\s*=\s*(.*?)\s*$/ and $section) {
	    $config{$section}{$1} = $2;
	    next unless $comment;
	    # Save comments from the default configuration file
	    $configcomments{$section}{$1} = $comment;
	    $comment = '';
	}
	elsif ( $l =~ m/^\s*\[(\w+?)\]\s*$/ ) { $section = $1 }
	elsif ( !$configfile and $l =~ m/^\s*#\s*(.*?)\s*$/ ) { $comment = $1 }
    }
    return;
}

sub MigrateConfig {
    # Load old configuration file if new file does not exist. If the
    # new file was created successfully, delete the old one.
    my ($old) = @_; if ( -e $old && !-e $configfile )
      { LoadConfig($old); SaveConfig(); unlink($old) if -e $configfile }
}

sub SaveConfig {
    # Write a new configuration file.
    # - Do not write a new file if there are no changes.
    # - Preserve order and comments.
    my @input;
    my @output = ();
    my $changed = 0;
    my $section = '';
    my @writtensec = ();
    my %written = ();
    my $chmod = 0;
    # Load the old config file, or else the default config
    if ( open F, '<', $configfile ) { @input = <F>; close F }
    else { @input = @{DefaultConfig()}; $changed = 1; $chmod = 1 }

    foreach my $l ( @input, '' ) {
	# Write a value
	if ( $l =~ m/^(\s*)(\w+?)(\s*=\s*)(.*?)(\s+)$/ ) {
	    my ($a,$key,$b,$value,$c) = ($1,$2,$3,$4,$5);
	    # Write out this key, checking if there were changes
	    if ( exists($config{$section}) and exists($config{$section}{$key})
		 and $config{$section}{$key} ne $value ) { $changed = 1 }
	    push @output, "$a$key$b$config{$section}{$key}$c";
	    $written{$section}{$key} = 1;
	}
	# Handle section boundary
	elsif ( $l =~ m/^(\s*\[)(\w+?)(\]\s*)$/ or !$l ) {
	    my ($a,$sec,$b) = ($1,$2,$3);
	    if ( $section and exists($config{$section}) ) {
		# Write out any leftover keys for the previous section.
		foreach my $k ( keys %{$config{$section}} ) {
		    next if exists($written{$section}{$k});
		    push @output, "# $configcomments{$section}{$k}\n"
		      if exists($configcomments{$section}) and
			exists($configcomments{$section}{$k});
		    push @output, "$k=$config{$section}{$k}\n";
		    $written{$section}{$k} = 1;
		    $changed = 1;	# File has changed
		}
	    }
	    last unless $l;
	    push @output, "$a$sec$b";
	    $section = $sec;
	    $section = '' if exists($written{$section}); # Don't write it twice
	}
	else { push @output, $l }
    }
    # Write out any leftover sections
    foreach my $sec ( keys %config ) {
	next if exists($written{$sec});
	push @output, "\n" unless @output and $output[-1] =~ m/^\s*\n$/;
	push @output, "[$sec]\n";
	foreach my $k ( keys %{$config{$sec}} ) {
	    push @output, "# $configcomments{$sec}{$k}\n"
	      if exists($configcomments{$sec}) and
		exists($configcomments{$sec}{$k});
	    push @output, "$k=$config{$sec}{$k}\n";
	}
	$changed = 1;			# File has changed
    }
    # Save the file if it changed. Chmod the file if it didn't exist before.
    if ( $changed ) {
	# Create the config directory
	mkpath(catpath((splitpath($configfile))[0..1]),{mode => 0700});
	open F, '>', $configfile or warn "Failed to open $configfile: $!\n";
	eval { chmod 0600, $configfile } if $chmod; # chmod newly created file
	print F @output;
	close F or warn "Failed to close $configfile: $!\n";
    }
}

# MPD Access functions
sub MPDReset {
    ClearMPDError();			# Clear the error
    MPDDisconnect();
}

sub MPDDisconnect {
    if ( $sock ) { close($sock); undef $sock }
    if ( $iowatch ) { Glib::Source->remove($iowatch); undef $iowatch }

    # Reset the status
    %status = ();
    %mpd = ();
    %stats = ( db_update => 0 );
    @rq = ();
    @playlist = ();
    MakeTooltip();
    $savedstate = '';
    $savedsongid = -1;
    $savedtransition = 0;
    $savedplaylist = -1;
    $pbcb = 0;
    $playbutton->set_active(0);
    $dboldupdate = 0;
    $dbwait = 1;

    # Reset the icon
    $iconmode = 0;
    IconExpose();

    # Blank the music chooser
    MC_RepopulateSel();
    MC_Repopulate();

    # Refresh preferences
    InvalidatePrefs();
}

sub MPDConnect {
    my ($interactive) = @_;
    MPDReset();
    my $host = $argvhost || $ENV{MPD_HOST} || $config{Connection}{MPDHost} ||
      'localhost';
    my $port = $argvport || $ENV{MPD_PORT} || $config{Connection}{MPDPort} ||
      6600;
    my $pass = $argvpass || $config{Connection}{MPDPass} || '';
    $pass = $1 if $host =~ s/^(.+)@// && !$argvpass &&
      (!$pass || $ENV{MPD_HOST});

    # Update the labels
    $tip[1] = '';
    $tip[2] = sprintf('Connecting to %s...',"$host:$port");
    UpdateLabels();

    sub TryIt {
	my ($host,$port,$pass) = @_;
	$sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port);
	if ( !$sock ) { ParseMPDError($!); return 0 }
	push @rq, \&MPDResponseSimple;
	$mpd{host} = $host;
	$mpd{port} = $port;
	if ( $pass ) {
	    MPDSend('password', $pass);
	    push @rq, \&MPDResponseSimple;
	    $argvpass = $pass;
	}
	MC_RepopulateSel();    # Update playlist dropdown on reconnect
	$iobuffer = '';
	$iowatch = Glib::IO->add_watch(fileno($sock), 'in', \&MPDCallback);
	return 1;
    }
    my $rc;
    foreach my $i ( 0..3 ) {
	last if $rc = TryIt($host,$port,$pass);
	last unless $config{Connection}{AutoStart};
	if ( $i == 0 ) {
	    delete $SIG{CHLD};		# Needed to get exit codes
	    my $rc = system($config{External}{MPDCommand}); # Start MPD
	    $SIG{CHLD} = 'IGNORE';	# Put it back
	    last if $rc != 0;
	}
	else { sleep $i }
    }
    $sock = undef unless $rc;
    $connecttime = time;
    if ( !$rc && $interactive ) {		# Interactive error
	my $msg = sprintf("Cannot connect to %s\n%s",
			  "$host:$port",$mpderror||'No error reported.');
	Prefs(2,$msg);
    }
    return $sock ? 1 : 0;
}

sub MPDReconnect {
    return if $sock;
    $reconnectin--;
    MPDConnect(0) if $reconnectin < 1;
    return;
}

sub MPDError {
    # MPD has dropped the connection.
    return 0 unless $sock;
    return MPDAuth() if $mpderror && ( $mpderrid == 3 || $mpderrid == 4 );

    # Reconnect
    $reconnectin = 10;
    MPDDisconnect();
    return 0;
}

sub MPDCallback {
    unless ( sysread($sock, $iobuffer, 4096, length($iobuffer)) ) {
	# Immediately retry if we have been connected for over a minute
	return MPDConnect(0) if time-$connecttime > 60; # FIXME - D/Cing???
	# Otherwise report an error
	ParseMPDError($!||'Read error'); MPDError()
    }
    while ( $iobuffer =~ s/^(((?!OK)(?!ACK)[^\n]*\n)*?(OK|ACK)[^\n]*)\n//gs ) {
	my @buf = split("\n",$1);
	my $callback = shift @rq;
	# TODO - Implement IDLE mode.
	$callback = \&MPDResponseSimple unless $callback; # For alien replies
	if ( $trace ) {
	    my $f = (ref($callback) eq 'CODE')? $callback : $callback->[0];
	    print $callbacknames{$f}||'(Unknown)',' ';
	}
	foreach my $x ( @buf ) {
	    $x =~ s/[\r\n]//g;
	    $x = decode('utf-8',$x);
	    if ( $trace )
	      { print '<'; print " $x\n" if $x =~ m/^OK|^ACK/ or $trace > 1 }
	}
	my $ref = ref($callback);
	if ( $ref eq 'CODE' ) { &$callback(\@buf) }
	elsif ( $ref eq 'ARRAY' ) {
	    my @callback = @$callback;
	    my $function = shift @callback;
	    &$function(\@buf,@callback);
	}
	else { die "Unknown callback format $ref" }
	if ( $mpderror ) {
	    return unless MPDError(); # Abandon the connection unless true.
	}
    }
    return 1;
}

sub MPDAuth {
    return 0 unless $sock && $mpderror && ( $mpderrid == 3 || $mpderrid == 4 );
    my $hostspec = "$mpd{host}:$mpd{port}";
    # Authentication problem
    if ( 0 and  $status{state}||'' ) { ClearMPDError() }
    else { MPDReset() } # Clear the error, disconnect

    Prefs(3,sprintf("Access denied: Enter password for\n%s", $hostspec));
    return $status{state}||'';
}

sub MPDPlay      { MPDSend('play',@_);      push @rq, \&MPDResponseSimple }
sub MPDPause     { MPDSend('pause');        push @rq, \&MPDResponseSimple }
sub MPDStop      { MPDSend('stop');         push @rq, \&MPDResponseSimple }
sub MPDNext      { MPDSend('next');         push @rq, \&MPDResponseSimple }
sub MPDPrev      { MPDSend('previous');     push @rq, \&MPDResponseSimple }
sub MPDSeek      { MPDSend('seek',@_);      push @rq, \&MPDResponseSimple }
sub MPDRandom    { MPDSend('random',@_);    push @rq, \&MPDResponseSimple }
sub MPDRepeat    { MPDSend('repeat',@_);    push @rq, \&MPDResponseSimple }
sub MPDSingle    { MPDSend('single',@_);    push @rq, \&MPDResponseSimple } #15
sub MPDConsume   { MPDSend('consume',@_);   push @rq, \&MPDResponseSimple } #15
sub MPDClear     { MPDSend('clear');        push @rq, \&MPDResponseSimple }
sub MPDAdd       { MPDSend('add',@_);       push @rq, \&MPDResponseSimple }
sub MPDDelete    { MPDSend('delete',@_);    push @rq, \&MPDResponseSimple }
sub MPDMove      { MPDSend('move',@_);      push @rq, \&MPDResponseSimple }
sub MPDVolume    { MPDSend('setvol',@_);    push @rq, \&MPDResponseSimple }
sub MPDXfade     { MPDSend('crossfade',@_); push @rq, \&MPDResponseSimple }

sub MPDStatus    { MPDSend('status');       push @rq, \&MPDResponseStatus }
sub MPDStats     { MPDSend('stats');        push @rq, \&MPDResponseStats }
sub MPDUpdateDB  { MPDSend('update');       push @rq, \&MPDResponseSimple }

sub MPDPlChanges { MPDSend('plchanges',@_); push @rq, \&MPDResponsePlChanges }

sub MPDSearch {
    my ($type,$query,$callback,@args) = @_;
    MPDSend('search',$type,$query);
    push @rq, [$callback, @args];
}

sub MPDList {
    my ($dir,$callback,@args) = @_;
    MPDSend('lsinfo',$dir);
    push @rq, [$callback, @args];
}

sub MPDListPlaylist {
    my ($pl,$callback,@args) = @_;
    MPDSend('listplaylistinfo',$pl);
    push @rq, [$callback, @args];
}

sub MPDPlMove   { MPDSend('playlistmove',@_);   push @rq, \&MPDResponseSimple }
sub MPDPlDelete { MPDSend('playlistdelete',@_); push @rq, \&MPDResponseSimple }
sub MPDPlClear  { MPDSend('playlistclear',@_);  push @rq, \&MPDResponseSimple }
sub MPDPlAdd    { MPDSend('playlistadd',@_);    push @rq, \&MPDResponseSimple }
sub MPDPlRemove { MPDSend('rm',@_);             push @rq, \&MPDResponseSimple }
sub MPDPlSave   { MPDSend('save',shift @_);push @rq, [\&MPDResponseMCSave,@_] }
sub MPDPlLoad   { MPDSend('load', @_);          push @rq, \&MPDResponseSimple }

sub MPDOutputs { MPDSend('outputs'); push @rq, [\&MPDResponseOutputs, @_] }
sub MPDEnableOutput
  { MPDSend('enableoutput',@_);  push @rq, \&MPDResponseSimple }
sub MPDDisableOutput
  { MPDSend('disableoutput',@_); push @rq, \&MPDResponseSimple }

sub MPDResponseStatus { %status = MPDResponseInfo(@_); UpdateStatus() }
sub MPDResponseStats { %stats = MPDResponseInfo(@_); UpdateStats() }
sub MPDResponsePlChanges { UpdatePlaylist(MPDResponseSongList(@_)) }
sub MPDResponseOutputs {
    my @list = MPDResponseRaw(shift @_);
    my $func = shift @_;
    &$func(\@list,@_);
}
sub MPDResponseMCSongList {
    my @results = MPDResponseSongList(shift @_);
    MC_RepopulateCallback(\@results, @_);
}
sub MPDResponseMCList {
    my @results = MPDResponseRaw(shift @_);
    MC_RepopulateSelCallback(\@results, @_);
}
sub MPDResponseMCSave {
    my ($lines,$func) = @_;
    MPDResponseSimple($lines);
    my $rc = $mpderror && $mpderrid == 56;
    ClearMPDError() if $rc; # No-Overwrite
    &$func($rc ? 0 : 1);
}

sub MPDSend {
    # FIXME - Remove old code
    unless ( $sock ) { return 0; ParseMPDError('Not Connected'); return 0 }
    my @l = ();
    foreach ( @_ ) { my $x = (m/ / or $_ eq '')?('"'.$_.'"'):$_; push @l, $x }
    my $msg = join(' ', @l);
    print "> $msg\n" if $trace;
    unless ( print $sock encode('utf-8',$msg),"\n" )
      { ParseMPDError($!||'Write error'); return 0 }
    return 1;
}

sub MPDResponseSimple {
    my $lines = shift @_;
    return unless ref($lines) eq 'ARRAY';
    foreach my $l ( @$lines ) {
	# Process response lines
	if ( $l =~ m/^OK/ ) { ClearMPDError(); last }
	if ( $l =~ m/^ACK/ ) { ParseMPDError($l); last }
    }
}

sub MPDResponseInfo {
    my %info = ();
    my $lines = shift @_;
    return unless ref($lines) eq 'ARRAY';
    foreach my $l ( @$lines ) {
	if ( $l =~ m/^(.+?)\s*:\s*(.+)$/ ) { $info{$1} = $2 }
	if ( $l =~ m/^OK/ ) { ClearMPDError(); last }
	if ( $l =~ m/^ACK/ ) { ParseMPDError($l); %info = (); last }
    }
    return %info;
}

sub MPDResponseSongList {
    my @list = ();
    my $info = {};
    my $n = 0;
    my $lines = shift @_;
    return unless ref($lines) eq 'ARRAY';
    foreach my $l ( @$lines ) {
	if ( $l =~ m/^file\s*:/ ) { push @list, $info if $n++; $info = {} }
	if ( $l =~ m/^(.+?)\s*:\s*(.+)$/ ) { $info->{$1} = $2 }
	if ( $l =~ m/^OK/ )
	  { ClearMPDError(); push @list, $info if $n++; last }
	if ( $l =~ m/^ACK/ ) { ParseMPDError($l); @list = (); last }
    }
    return @list;
}

sub MPDResponseRaw {
    my @list = ();
    my $lines = shift @_;
    return unless ref($lines) eq 'ARRAY';
    foreach my $l ( @$lines ) {
	push @list, $l;
	if ( $l =~ m/^OK/ ) { ClearMPDError(); last }
	if ( $l =~ m/^ACK/ ) { ParseMPDError($l); @list = (); last }
    }
    return @list;
}

sub ParseMPDError {
    my ($l) = @_;
    $l =~ m/^ACK \[(\d+)@\d+]\s*\{([^\}]+)\}\s*(.+)$/;
    $mpderror = ($2 && $3) ? "$2: $3" : $l;
    $mpderrid = $1||0;
}

sub ClearMPDError {
    $mpderror = undef;
    $mpderrid = 0;
}

# Preferences

sub Prefs {
    my ($connectdlg, $connectmsg) = @_;
    if ( $prefsdlg and $connectdlg ) { $prefsdlg->destroy; undef $prefsdlg }
    return $prefsdlg->present if $prefsdlg;
    my $dialog = $prefsdlg =
      Gtk2::Dialog->new($connectdlg ? 'Yocto' : 'Yocto Preferences',
			undef,'modal', ());
    if ( $connectdlg ) {
	$dialog->add_button('gtk-cancel','reject');
	$dialog->add_button('gtk-connect', 'accept');
    }
    else { $dialog->add_button('gtk-close', 'accept') }
    $dialog->set_default_response('accept');
    $dialog->set_position('center');
    $dialog->set_has_separator(0);
    $dialog->set_resizable(0);

    my $notebook = Gtk2::Notebook->new();

    my $general = Gtk2::VBox->new();

    my $tracknotify = Gtk2::CheckButton->new('Show _popup when track changes');
    $tracknotify->set_active($config{Settings}{TrackNotify} ? 1 : 0);
    $tracknotify->signal_connect('toggled',sub { $config{Settings}{TrackNotify} = $_[0]->get_active() ? 1 : 0 ; $savedstate = ''; 0 });
    $general->pack_start($tracknotify,0,0,0);

    my $showcovers = Gtk2::CheckButton->new("Display album _covers");
    $showcovers->set_active($config{Settings}{ShowCovers} ? 1 : 0);
    $showcovers->signal_connect('toggled',sub { $config{Settings}{ShowCovers} = $_[0]->get_active() ? 1 : 0 ; $savedstate = ''; 0 });
    $general->pack_start($showcovers,0,0,0);
    my $coversnote = Gtk2::Label->new('<small>Music Location is used to find cover images.</small>');
    $coversnote->set_use_markup(1);
    $coversnote->set_alignment(0,0);
    $general->pack_start($coversnote,0,0,0);

    my $server = Gtk2::VBox->new();
    my $padserverbox = 0;
    if ( ( $connectdlg == 2 or $connectdlg == 3) && $connectmsg ) {
	my $alertbox = Gtk2::HBox->new();
	my $icon = $connectdlg == 3 ?
	  'gtk-dialog-authentication' : 'gtk-dialog-error';
	my $alerticon = Gtk2::Image->new_from_stock($icon,'dnd');
	my $alert = Gtk2::Label->new($_[1]);
	$alertbox->pack_start($alerticon,0,0,0);
	$alertbox->pack_start($alert,0,0,0);
	$server->pack_start($alertbox,0,0,0);
	$padserverbox = 8;
    }
    if ( $argvport or $ENV{MPD_PORT} or $argvhost or $ENV{MPD_HOST} ) {
	my $alertbox = Gtk2::HBox->new();
	my $alerticon = Gtk2::Image->new_from_stock('gtk-dialog-warning','dnd');
	my $alert = Gtk2::Label->new("Some settings have been overridden\nand cannot be changed.");
	$alertbox->pack_start($alerticon,0,0,0);
	$alertbox->pack_start($alert,0,0,0);
	$server->pack_start($alertbox,0,0,0);
	$padserverbox = 8;
    }

    if ( $padserverbox ) {
	my $a = Gtk2::Alignment->new(0,0,0,0);
	$a->set_padding($padserverbox,0,0,0);
	$server->pack_start($a,0,0,0);
    }
    my $servertable = Gtk2::Table->new(6,2);

    my $hostentry = Gtk2::Entry->new();
    $hostentry->set_activates_default(1);
    $hostentry->set_text($config{Connection}{MPDHost});
    my $hostlabel = Gtk2::Label->new('_Host: ');
    ($hostlabel->set_sensitive(0),$hostentry->set_sensitive(0))
      if $argvhost or $ENV{MPD_HOST};
    $hostlabel->set_use_underline(1);
    $hostlabel->set_mnemonic_widget($hostentry);
    $hostlabel->set_alignment(0,0.5);
    $servertable->attach($hostlabel,0,1,0,1,'fill','fill',0,0);
    $servertable->attach($hostentry,1,2,0,1,['expand','fill'],'fill',0,0);
    $hostentry->grab_focus() if $connectdlg == 2;

    my $portentry = Gtk2::Entry->new();
    $portentry->set_activates_default(1);
    $portentry->set_text($config{Connection}{MPDPort});
    my $portlabel = Gtk2::Label->new('_Port: ');
    ($portlabel->set_sensitive(0),$portentry->set_sensitive(0))
      if $argvport or $ENV{MPD_PORT};
    $portlabel->set_use_underline(1);
    $portlabel->set_mnemonic_widget($portentry);
    $portlabel->set_alignment(0,0.5);
    $servertable->attach($portlabel,0,1,1,2,'fill','fill',0,0);
    $servertable->attach($portentry,1,2,1,2,['expand','fill'],'fill',0,0);

    my $sernotice = Gtk2::Label->new('<small>The default host is localhost, the default port is 6600.</small>');
    $sernotice->set_alignment(0,0);
    $sernotice->set_use_markup(1);
    $sernotice->set_line_wrap(1);
    $servertable->attach($sernotice,0,2,2,3,['expand','fill'],'fill',0,0);

    my $autostart = Gtk2::CheckButton->new("Try _starting MPD if connection fails");
    $autostart->set_active($config{Connection}{AutoStart} ? 1 : 0);
    $autostart->signal_connect('toggled',sub { $config{Connection}{AutoStart} = $_[0]->get_active() ? 1 : 0 ; 0 });
    $servertable->attach($autostart,0,2,3,4,['expand','fill'],'fill',0,0);

    $servertable->set_row_spacing(3,8);

    my $passentry = Gtk2::Entry->new();
    $passentry->set_activates_default(1);
    $passentry->set_visibility(0);
    $passentry->set_text($config{Connection}{MPDPass});
    my $passlabel = Gtk2::Label->new('P_assword: ');
    $passlabel->set_use_underline(1);
    $passlabel->set_mnemonic_widget($passentry);
    $passlabel->set_alignment(0,0.5);
    $servertable->attach($passlabel,0,1,4,5,'fill','fill',0,0);
    $servertable->attach($passentry,1,2,4,5,['expand','fill'],'fill',0,0);
    $passentry->grab_focus() if $connectdlg == 3;

    my $savecheck = Gtk2::CheckButton->new('_Remember this password');
    $savecheck->set_active($config{Connection}{MPDPass} ? 1 : 0);
    $servertable->attach($savecheck,1,2,5,6,['expand','fill'],'fill',0,0);

    $servertable->set_col_spacing(0,5);
    $server->pack_start($servertable,0,0,0);

    my $dirhbox = Gtk2::HBox->new();
    my $direntry = Gtk2::Entry->new();
    $direntry->set_text($config{External}{MusicDirectory});
    #$direntry->set_alignment(0,0.5);

    my $dirbutton = Gtk2::Button->new();
    $dirbutton->add(Gtk2::Image->new_from_stock('gtk-open','menu'));
    $dirbutton->signal_connect
      ('clicked',
       sub {
	   my $dirselect = Gtk2::FileChooserDialog->new('Select Music Location',$dialog,'select-folder',('gtk-cancel','reject','gtk-open','accept'));
	   $dirselect->set_local_only(1);
	   $dirselect->set_filename($direntry->get_text()||$xdgmusic||'');
	   my $r = $dirselect->run();
	   $direntry->set_text($dirselect->get_filename()) if $r eq 'accept';
	   $dirselect->destroy();
       });
    my $dirlabel = Gtk2::Label->new('Music _Location: ');
    $dirlabel->set_use_underline(1);
    $dirlabel->set_mnemonic_widget($direntry);
    $dirlabel->set_alignment(0,0.5);
    $dirhbox->pack_start($dirlabel,0,0,0);
    $dirhbox->pack_start($direntry,1,1,0);
    $dirhbox->pack_start($dirbutton,0,0,0);
    $server->pack_start($dirhbox,0,0,0) unless $connectdlg;

    my $audio = Gtk2::VBox->new();

    my $volbox = Gtk2::HBox->new();
    my $volscale = Gtk2::HScale->new();
    $volscale->set_update_policy('delayed');
    $volscale->set_value_pos('left');
    $volscale->set_draw_value(1);
    $volscale->set_range(0,100);
    $volscale->set_value($status{volume}||0);
    $volscale->signal_connect('format-value',sub { int($_[1])."%" });
    $volscale->signal_connect('value-changed', sub { MPDVolume(int($volscale->get_value)); 0 });
    $volbox->set_sensitive(0) if !defined($status{volume});
    $volbox->signal_connect('expose-event', sub {
				my $sens = $volbox->get_property('sensitive');
				if ( !$sens && defined($status{volume}) ) {
				    $volscale->set_value($status{volume});
				    $volbox->set_sensitive(1);
				}
				elsif ( $sens && !defined($status{volume}) ) {
				    $volscale->set_value(0);
				    $volbox->set_sensitive(0);
				}});

    my $vollabel = Gtk2::Label->new('_Volume:');
    $vollabel->set_use_underline(1);
    $vollabel->set_mnemonic_widget($volscale);
    $vollabel->set_alignment(0,0.5);
    $volbox->pack_start($vollabel,0,0,0);
    $volbox->pack_start($volscale,1,1,0);
    $audio->pack_start($volbox,0,0,0);

    my $xfadebox = Gtk2::HBox->new();
    my $xfadeadj = Gtk2::Adjustment->new(0,0,30,1,5,0);
    my $xfadescale = Gtk2::SpinButton->new($xfadeadj,0,0);
    $xfadescale->set_update_policy('if-valid');
    $xfadescale->set_numeric(1);
    $xfadescale->set_value($status{xfade}||0);
    $xfadescale->signal_connect('value-changed', sub { MPDXfade(int($xfadescale->get_value)); 0 });
    $xfadebox->set_sensitive(0) if !defined($status{xfade});
    $xfadebox->signal_connect('expose-event', sub {
				my $sens = $xfadebox->get_property('sensitive');
				if ( !$sens && defined($status{xfade}) ) {
				    $xfadescale->set_value($status{xfade});
				    $xfadebox->set_sensitive(1);
				}
				elsif ( $sens && !defined($status{xfade}) ) {
				    $xfadescale->set_value(0);
				    $xfadebox->set_sensitive(0);
				}});

    my $xfadelabel = Gtk2::Label->new('_Crossfade:');
    $xfadelabel->set_use_underline(1);
    $xfadelabel->set_mnemonic_widget($xfadescale);
    $xfadelabel->set_alignment(0,0.5);
    $xfadebox->pack_start($xfadelabel,0,0,0);
    $xfadebox->pack_end(Gtk2::Label->new('seconds'),0,0,0);
    $xfadebox->pack_end($xfadescale,0,0,0);
    $audio->pack_start($xfadebox,0,0,0);

    my $outputmodel = Gtk2::ListStore->new('Glib::Int', # outputid
					   'Glib::Boolean', # outputenabled
					   'Glib::String'); # outputname
    my $outputs = Gtk2::TreeView->new($outputmodel);
    $outputs->set_headers_visible(0);

    my $outlabel = Gtk2::Label->new('Audio _outputs:');
    $outlabel->set_use_underline(1);
    $outlabel->set_mnemonic_widget($outputs);
    $outlabel->set_alignment(0,0.5);
    $audio->pack_start($outlabel,0,0,0);

    my $crt = Gtk2::CellRendererToggle->new();
    $crt->signal_connect('toggled',\&OutputToggled,[$outputmodel,$outputs]);
    my $cola = Gtk2::TreeViewColumn->new_with_attributes
      ('',$crt, active => 1);
    $outputs->append_column($cola);
    my $colb = Gtk2::TreeViewColumn->new_with_attributes
      ('',Gtk2::CellRendererText->new(), text => 2);
    $outputs->append_column($colb);
    my $outputsw = Gtk2::ScrolledWindow->new();
    $outputsw->add($outputs);
    $outputsw->set_shadow_type('etched-in');
    $outputsw->set_policy('never','automatic');
    $outputsw->set_size_request(1,100);
    $audio->pack_start($outputsw,1,1,0);
    $outputs_populated = 0;
    $outputs->signal_connect('expose-event',\&ExposeOutputs,
			    [$outputmodel,$outlabel,$outputsw]);
    $outlabel->set_sensitive(0);
    $outputsw->set_sensitive(0);

    sub ExposeOutputs {
	my ($outputs,$event,$args) = @_;
	return 0 if $outputs_populated;
	return PopulateOutputs(undef, @$args) unless $sock;
	MPDOutputs(\&PopulateOutputs, @$args);
    }
    sub PopulateOutputs {
	my ($outputs,$outputmodel,$outlabel,$outputsw) = @_;
	$outputmodel->clear();
	$outlabel->set_sensitive(0);
	$outputsw->set_sensitive(0);
	return 0 unless $outputs and @$outputs;
	$outputs_populated = 1;
	my %output = ();
	foreach ( @$outputs, 'outputid:' ) {
	    if ( m/^outputid:/ && %output ) {
		$outputmodel->insert_with_values(-1,0,$output{outputid},
						 1,$output{outputenabled}?1:0,
						 2,$output{outputname});
		%output = ();
	    }
	    if ( m/^(\w+): (.+)$/ ) { $output{$1} = $2 }
	}
	$outlabel->set_sensitive(1);
	$outputsw->set_sensitive(1);
	return 0;
    }
    sub OutputToggled {
	my ($crt,$path,$args) = @_;
	my ($model,$outputs) = @$args;
	my $iter = $model->get_iter(Gtk2::TreePath->new_from_string($path));
	my $id = $model->get($iter,0);
	my $active = $model->get($iter,1);
	if ( $active ) { MPDDisableOutput($id) }
	else { MPDEnableOutput($id) }
	$outputs_populated = 0;
    }

    my $library = Gtk2::VBox->new();
    @prefs_stats = ();
    foreach (0..4) {
	my $l = Gtk2::Label->new($prefs_stats_l[$_]);
	$l->set_alignment(0,0.5);
	$library->pack_start($l,0,0,0);
    }
    my $updalign = Gtk2::Alignment->new(1,0.5,0,0);
    my $updbut = Gtk2::Button->new_from_stock('gtk-refresh');
    $updbut->signal_connect
      ('clicked', sub { $dboldupdate = $stats{db_update}; $dbwait = 120; MPDUpdateDB() });
    $updalign->add($updbut);
    $library->pack_start($updalign,0,0,0);

    my $advanced = Gtk2::VBox->new();

    my $refillentry = Gtk2::Entry->new();
    $refillentry->set_text($config{External}{RefillCommand});
    my $refilllabel = Gtk2::Label->new('_Refill command: <small>(Run to add songs to the playlist)</small>');
    $refilllabel->set_use_markup(1);
    $refilllabel->set_alignment(0,0);
    $refilllabel->set_use_underline(1);
    $refilllabel->set_mnemonic_widget($refillentry);
    $advanced->pack_start($refilllabel,0,0,0);
    $advanced->pack_start($refillentry,0,0,0);

    my $mpdcmdentry = Gtk2::Entry->new();
    $mpdcmdentry->set_text($config{External}{MPDCommand});
    my $mpdcmdlabel = Gtk2::Label->new('_MPD command: <small>(Run to start the MPD daemon)</small>');
    $mpdcmdlabel->set_use_markup(1);
    $mpdcmdlabel->set_alignment(0,0);
    $mpdcmdlabel->set_use_underline(1);
    $mpdcmdlabel->set_mnemonic_widget($mpdcmdentry);
    $advanced->pack_start($mpdcmdlabel,0,0,0);
    $advanced->pack_start($mpdcmdentry,0,0,0);

    if ( $connectdlg ) {
	my $serbox = Gtk2::VBox->new();
	my $serlabel = Gtk2::Label->new('<big><b>Welcome to Yocto</b></big>');
	$serlabel->set_use_markup(1);
	$serlabel->set_alignment(0,0);
	$serbox->add($serlabel);
	my $seralign = Gtk2::Alignment->new(0.5,0.5,1,1);
	#$seralign->set_padding(0,0,12,0);
	$seralign->add($server);
	$serbox->add($seralign);
	$serbox->set_border_width(10);
	$dialog->vbox->pack_start($serbox,0,0,0);
    }
    else {
	$general->set_border_width(10);
	$notebook->append_page($general,Gtk2::Label->new('General'));

	$server->set_border_width(10);
	$notebook->append_page($server,Gtk2::Label->new('Server'));

	$audio->set_border_width(10);
	$notebook->append_page($audio,Gtk2::Label->new('Audio'));

	$library->set_border_width(10);
	$notebook->append_page($library,Gtk2::Label->new('Library'));

	$advanced->set_border_width(10);
	$notebook->append_page($advanced,Gtk2::Label->new('Advanced'));

	my $nbvbox = Gtk2::VBox->new();
	$nbvbox->set_border_width(5);
	$nbvbox->add($notebook);
	$dialog->vbox->add($nbvbox);
    }
    $dialog->show_all;
    $dialog->signal_connect
      ('response', sub {
	   my ($dialog,$r) = @_;
	   $prefsdlg = undef;
	   @prefs_stats = ();

	   my $newhost = $hostentry->get_text();
	   my $newport = $portentry->get_text();
	   my $newpass = $passentry->get_text();
	   # Apparently the value of a hidden GtkEntry may disappear.
	   # Or it's a bug in GTK 2.24.10.
	   if ( !$connectdlg ) {
	       $config{External}{RefillCommand} = $refillentry->get_text();
	       $config{External}{MPDCommand} = $mpdcmdentry->get_text();
	       my $newdir = $direntry->get_text(); #$dirselect->get_filename();
	       if ( $newdir ne $config{External}{MusicDirectory} ) {
	           $config{External}{MusicDirectory} = $newdir;
	           $savedstate = '';
	       }
	   }
	   $dialog->destroy;
	   if ( $newhost ne $config{Connection}{MPDHost} or
		$newport ne $config{Connection}{MPDPort} or
		$newpass ne $config{Connection}{MPDPass} or
		(!$savecheck->get_active() && $config{Connection}{MPDPass}) or
		( $connectdlg and $r eq 'accept' ) ) {
	       $config{Connection}{MPDHost} = $newhost;
	       $config{Connection}{MPDPort} = $newport;
	       $config{Connection}{MPDPass} = $savecheck->get_active() ?
		 $newpass : '';
	       $argvpass = $newpass;
	       SaveConfig();			# Save preferences
	       MPDConnect(1);
	   }
	   elsif ( $r eq 'accept' ) { SaveConfig() } # Save preferences
       });
}

sub InvalidatePrefs {
    return unless $prefsdlg;
    $outputs_populated = 0;
    my $rect = Gtk2::Gdk::Rectangle->new(0,0,$prefsdlg->window->get_size());
    $prefsdlg->window->invalidate_rect($rect,1);
}

# Music Chooser

sub MC_Show {
    if ( !$mcwnd ) {
	$mcwnd = Gtk2::Window->new('toplevel');
	$mcwnd->set_default_size(600,400); # TODO - Persistant geometry!
	my $vbox = Gtk2::VBox->new();
	my $topbox = Gtk2::HBox->new();

	$mcsel = Gtk2::ComboBox->new($mcselmodel);
	my $mcselcr = Gtk2::CellRendererText->new();
	$mcsel->set_size_request(222,-1);
	$mcsel->pack_start($mcselcr,1);
	$mcsel->set_attributes($mcselcr,text => 1);
	$mcsel->signal_connect('changed',\&MC_Repopulate);
	$mcsel->set_row_separator_func
	  (sub { my ($model,$iter) = @_; return $model->get($iter,0) eq ':' });
	$topbox->pack_start($mcsel,0,0,0);

	$mcsearch = Gtk2::Entry->new();
	$mcsearch->set_size_request(222,-1);
	$mcsearch->set_activates_default(0);
	$mcsearch->signal_connect('activate', sub { $mcquery = $mcsearch->get_text(); $mcsel->set_active(-1); $mcsel->set_active(1); });
	$topbox->pack_end($mcsearch,0,0,0);
	$mcsearchlabel = Gtk2::Label->new('   Search _Library: ');
	$mcsearchlabel->set_use_underline(1);
	$mcsearchlabel->set_mnemonic_widget($mcsearch);
	$topbox->pack_end($mcsearchlabel,0,0,0);

	$vbox->pack_start($topbox,0,0,0);

	$mctreemodel = Gtk2::ListStore->new('Glib::String', # Identifier
					    'Glib::Boolean', # Current Song
					    'Glib::String', # Visible markup
					    'Glib::Int');   # Index
	$mctreemodel->signal_connect('row-inserted',\&MC_Reordered);
	$mctree = Gtk2::TreeView->new($mctreemodel);
	$mctree->set_headers_visible(0);
	eval { $mctree->set_grid_lines('horizontal') }; # Requires GTK 2.10
	$mctree->get_selection()->set_mode('multiple');
	$mctree->signal_connect('row-activated',\&MC_ActivateRow);
	my $cra = Gtk2::CellRendererPixbuf->new();
	my $cola = Gtk2::TreeViewColumn->new_with_attributes('',$cra);
	$cola->set_cell_data_func
	  ($cra, sub {
	       my ($col, $cell, $model, $iter) = @_;
	       $cell->set_property
		 ('pixbuf', $model->get($iter,1) ?
		  $mctree->render_icon('gtk-media-play','small-toolbar'):undef)
	     });
	$mctree->append_column($cola);
	my $colb = Gtk2::TreeViewColumn->new_with_attributes
	  ('',Gtk2::CellRendererText->new(), markup => 2);
	$mctree->append_column($colb);
	my $scroller = Gtk2::ScrolledWindow->new();
	$scroller->add($mctree);
	$scroller->set_shadow_type('etched-in');
	$scroller->set_policy('never','automatic');
	$scroller->set_size_request(1,100);
	$vbox->pack_start($scroller,1,1,0);

	$mcbutbox = Gtk2::HBox->new();
	$vbox->pack_start($mcbutbox,0,0,0);

	$mcwnd->add($vbox);
	$mcwnd->signal_connect('delete-event', \&MC_Hide);
        # Keyboard accelerators
        $mcaccelgroup = Gtk2::AccelGroup->new();
        $mcaccelgroup->connect(Gtk2::Accelerator->parse('<Control>w'), [],
                               \&MC_Hide);
        $mcwnd->add_accel_group($mcaccelgroup);
        # FIXME: Add more accelerators
        #$mcsave->add_accelerator('activate', $mcaccelgroup,
        #                         Gtk2::Accelerator->parse('<Control>s'), []);
    }
    $mcvisible = 1;
    MC_RepopulateSel();
    $mcsel->set_active(-1);
    $mcsel->set_active(0);
    $mcwnd->show_all;
}
sub MC_Hide { $mcwnd->hide; $mcvisible = 0; 1 }
sub MC_Repopulate {			# Repopulate the main view
    return $mcscrollnext = 1 unless $mcvisible;
    $mcreorder = 1;
    $mctreemodel->clear();
    $mctree->set_reorderable(0);
    $mcreorder = 0;
    return $mcscrollnext = 1 if $mcsel->get_active() < 0;
    my $iter = $mcsel->get_active_iter();
    my $path = $mcselmodel->get($iter,0);
    my ($type,$arg) = ($mctype,$mcarg) = split ':', $path;
    if ( $type eq 'np' ) {
	$mcwnd->set_title('Now Playing');
	$mctree->set_reorderable(1);
	return MC_RepopulateCallback(\@playlist, $type);
    }
    elsif ( $type eq 'sr' ) {
	$mcwnd->set_title('Search Results');
	if ( length($mcquery||'') >= 3 )
	  { MPDSearch('any', $mcquery||'', \&MPDResponseMCSongList, $type) }
	else { my @list = (); MC_RepopulateCallback(\@list, $type) }
    }
    elsif ( $type eq 'pl' ) {
	$mcwnd->set_title($arg);
	$mctree->set_reorderable(1);
	MPDListPlaylist($arg, \&MPDResponseMCSongList, $type);
    }
    else { return }
}
sub MC_RepopulateCallback {
    my @list = @{shift @_};
    my ($type) = @_;
    my $scrollto = 0;
    my $i = 0;
    $mcreorder = 1;
    if ( $type eq 'np' ) { $scrollto = $status{song} }
    if ( $type eq 'sr' ) {
    	no warnings;
	@list = sort { ($a->{Album}||'') cmp ($b->{Album}||'')
			 || ($a->{Track}||0) <=> ($b->{Track}||0) } @list
			   if $list[0];
    }
    foreach ( @list ) {
	last unless $_;
	my %song = %$_;
	#$song{$_} = decode('utf-8',$song{$_}) foreach keys %song;
	my @song = FormatSong(%song);
	$song[0] = ($type eq 'np' or $type eq 'pl') ?
	  ('<b>'.($i+1).". $song[0]</b>") :
	    "<b>$song[0]</b>";
	my $current = 0;
	$current = ((defined($status{songid}) ? $status{songid} : -1)
		    eq (exists($song{Id}) ? $song{Id} : -2)) ? 1 : 0
		      if ($status{state}||'') eq 'play' or
			($status{state}||'') eq 'pause';

	$mctreemodel->insert_with_values(-1, 0, $_->{file}, 1, $current,
					 2, join("\n", @song), 3, $i);
	$i++;
    }
    if ( $mcscrollnext ) {
	if ( $scrollto )
	  { $mctree->scroll_to_cell(Gtk2::TreePath->new_from_string($scrollto),
				    undef,1,0.5,0) }
	else { $mctree->realize; $mctree->scroll_to_point(0,0) }
    }
    $mcscrollnext = 1;
    # Buttons!
    $mcbutbox->foreach(sub { $mcbutbox->remove($_[0]) });

    my $tmpbut;
    if ( $type eq 'np' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-save');
	$mcbutbox->pack_start($tmpbut,0,0,0);
	$tmpbut->signal_connect('clicked', \&MC_Save);
    }
    if ( $type eq 'pl' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-delete');
	$mcbutbox->pack_start($tmpbut,0,0,0);
	$tmpbut->signal_connect('clicked', \&MC_Delete);
    }
    if ( $type eq 'np') {		# or $type eq 'pl'
	$tmpbut = Gtk2::Button->new_from_stock('gtk-clear');
	$mcbutbox->pack_start($tmpbut,0,0,0);
	$tmpbut->signal_connect('clicked', \&MC_Clear);
    }
    if ( $type eq 'sr' or $type eq 'pl' ) {
	$tmpbut = Gtk2::Button->new_with_mnemonic('Add a_ll');
	$tmpbut->set_image(Gtk2::Image->new_from_stock('gtk-add','button'));
	$mcbutbox->pack_start($tmpbut,0,0,0);
	$tmpbut->signal_connect('clicked',\&MC_AddAll);
    }
    if ( $type eq 'pl' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-media-play');
	$mcbutbox->pack_start($tmpbut,0,0,0);
	$tmpbut->signal_connect
	  ('clicked', sub { MPDClear(); MC_AddAll(); MPDPlay(0); Update();
			    $mcsel->set_active(0) });
    }
    if ( $type eq 'sr' or $type eq 'pl' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-add');
	$mcbutbox->pack_end($tmpbut,0,0,0);
	$tmpbut->set_flags('can-default');
	$tmpbut->grab_default();
	$tmpbut->signal_connect('clicked',\&MC_AddSel);
    }
    if ( $type eq 'np' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-jump-to');
	$mcbutbox->pack_end($tmpbut,0,0,0);
	$tmpbut->set_flags('can-default');
	$tmpbut->grab_default();
	$tmpbut->signal_connect('clicked',\&MC_JumpTo);
    }
    if ( $type eq 'np' or $type eq 'pl' ) {
	$tmpbut = Gtk2::Button->new_from_stock('gtk-remove');
	$mcbutbox->pack_end($tmpbut,0,0,0);
	$tmpbut->signal_connect('clicked',\&MC_RemSel);
    }

    # Disable controls if disconnected
    $_->set_sensitive($sock ? 1 : 0) foreach $mcsel, $mcsearch, $mcsearchlabel;
    $mcbutbox->foreach(sub { $_[0]->set_sensitive(0) }) unless $sock;

    $mcbutbox->show_all;
    $mcreorder = 0;
}

sub MC_RepopulateSel {			# Repopulate the drop down
    #return unless $mcvisible;
    return MC_RepopulateSelCallback() unless $sock;
    MPDList('',\&MPDResponseMCList);
}
sub MC_RepopulateSelCallback {
    $mcselmodel->clear();
    $mcselmodel->insert_with_values(-1,0,'np:',1,'Now Playing');
    $mcselmodel->insert_with_values(-1,0,'sr:',1,'Search Results');
    $mcselmodel->insert_with_values(-1,0,':');
    $mcsel->set_active(0) if $mcvisible;
    return unless $_[0];
    my @pls = ();
    foreach ( sort @{$_[0]} ) {
	push @pls, $_ if s/^playlist: //; # Why can't I use an m/ here??
    }
    $mcselmodel->insert_with_values(-1,0,'pl:'.$_,1,$_) foreach sort @pls;

}

sub MC_AddAll {
    my $iter = $mctreemodel->get_iter_first();
    return unless $iter;
    do { MPDAdd($mctreemodel->get($iter,0)) }
      while ( $iter = $mctreemodel->iter_next($iter) );
}

sub MC_AddSel {
    my $sel = $mctree->get_selection();
    foreach my $pos (sort { $a->to_string() <=> $b->to_string() }
		     $sel->get_selected_rows()) {
	my $iter = $mctreemodel->get_iter($pos);
	MPDAdd($mctreemodel->get($iter,0));
    }
}

sub MC_JumpTo {
    return unless $mctype eq 'np';
    my $sel = $mctree->get_selection();
    my $pos = ($sel->get_selected_rows())[0] or return;
    MPDPlay($pos->to_string());
}

sub MC_RemSel {
    return unless $mctype eq 'np' or $mctype eq 'pl';
    my $sel = $mctree->get_selection();
    # In ASCENDING order to keep indices valid
    my @sel = map { $_->to_string() } $sel->get_selected_rows();
    foreach my $pos (sort { $b <=> $a } @sel) {
	if ( $mctype eq 'np' ) { MPDDelete($pos) }
	elsif ( $mctype eq 'pl' ) { MPDPlDelete($mcarg,$pos) }
	$mctreemodel->remove($mctreemodel->get_iter_from_string($pos));
    }
    MC_Repopulate() if $mctype eq 'pl';	# Playlists are not cached
}

sub MC_ActivateRow {
    my ($tree,$path,$col) = @_;
    $mctree->get_selection()->select_path($path);
    $mcwnd->activate_default();
}

sub MC_Reordered {
    return unless $mctype eq 'np' or $mctype eq 'pl';
    return if $mcreorder;
    my ($model,$path) = @_;
    my $iter = $model->get_iter($path);
    Glib::Timeout->add(10,sub {
			   my ($iter) = @_;
			   my $dest = $mctreemodel->get_path($iter)->to_string();
			   my $src = $mctreemodel->get($iter,3);
			   if ( $mctype eq 'np' ) { MPDMove($src,$dest) }
			   elsif ( $mctype eq 'pl' ) {
			       MPDPlMove($mcarg,$src,$dest);
			       MC_Repopulate();	# Playlists are not cached
			   }
			   return 0;
			   },$iter);
}

sub MC_Clear {
    $mctreemodel->clear();    # Clear treeview for fast feedback
    if ( $mctype eq 'np' ) { MPDClear() }
    elsif ( $mctype eq 'pl' ) { MPDPlClear($mcarg) }
}

sub MC_Delete {
    return if $mctype ne 'pl';
    my $dialog = Gtk2::MessageDialog
      ->new_with_markup(undef, 'modal','warning', 'none',
			'<span weight="bold" size="large">'.
			sprintf('Are you sure you want to delete the playlist "%s"?',$mcarg)
			."</span>\n\n".
			'Deleted playlists cannot be recovered later.');
    $dialog->add_button('gtk-cancel','reject');
    $dialog->add_button('gtk-delete', 'accept');
    $dialog->set_default_response('accept');
    my $rc = $dialog->run;
    $dialog->destroy;
    if ( $rc eq 'accept' ) {
	MPDPlRemove($mcarg);
	MC_RepopulateSel();
	$mcsel->set_active(0);
    }
}

sub MC_Save {
    return if $mctype ne 'np';
    my $dialog = Gtk2::Dialog->new('Save Playlist',undef,'modal', ());
    $dialog->add_button('gtk-cancel','reject');
    $dialog->add_button('gtk-save', 'accept');
    $dialog->set_default_response('accept');

    my $hbox = Gtk2::HBox->new();
    my $entry = Gtk2::Entry->new();
    $entry->set_size_request(333,-1);
    $entry->set_activates_default(1);
    my $label = Gtk2::Label->new('_Name:');
    $label->set_use_underline(1);
    $label->set_mnemonic_widget($entry);
    $hbox->pack_start($label,0,0,0);
    $hbox->pack_start(Gtk2::Label->new(''),0,0,5);
    $hbox->pack_end($entry,1,1,0);
    $hbox->set_border_width(10);
    $dialog->vbox->add($hbox);
    $dialog->signal_connect('response', sub {
				my ($dialog,$response) = @_;
				return $dialog->destroy()
				  unless $response eq 'accept';
				my $v = $entry->get_text();
				return 0 if !length($v) or $v =~ m/\//;
				MPDPlSave($v, sub {
					      my ($rc) = @_;
					      if ( $rc ) {
						  $dialog->destroy();
						  MC_RepopulateSel();
						  $mcsel->set_active(0);
						  return;
					      }
					      OverwriteError($dialog,$v);
					  });
				return 0;
			    });
    $dialog->show_all;
    $dialog->run;
    sub OverwriteError {
	my ($dialog,$v) = @_;
	my $confirm = Gtk2::MessageDialog
	  ->new_with_markup($dialog, 'modal','error', 'none',
			    '<span weight="bold" size="large">'.
			    sprintf('There is already a playlist named "%s".',
				    $v)."</span>\n\n".
			    'A playlist with this name already exists.');
	$confirm->add_button('gtk-ok','reject');
	$confirm->run;
	$confirm->destroy;
    }
}

1;
__DATA__
